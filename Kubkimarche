# -*- coding: utf-8 -*-
"""
Ce programme Python calcule la température en 2D sur une boîte carré de longueur L.
"""

import numpy as np
from numpy.linalg import inv
import matplotlib.pyplot as plt
import time


########################### D E F I N I T I O N S #######################

def f(x):
    """
    Définit U[0] en chaque point d'affixe x, i.e la température sur la barre à t = 0
    """
    return abs(100 * np.sin(x / 2) + 20)


def matrice_AB(r, taille_mat):
    '''
        Calcul des deux matrices carrées A et B pour le calcul de récurrence du modèle.
        On ne les calcule qu'une fois pour réduire considérablement les calculs répétitifs inutiles
    
        Paramètres
        ----------
        r : flottant.
        taille_mat : entier.
            Correspond au nombre de lignes/colonnes de la matrice 
    
        Retours
        -------
        A : tableau numpy
        B : tableau numpy
    '''

    A = np.zeros((taille_mat - 2, taille_mat - 2))
    B = np.zeros((taille_mat - 2, taille_mat - 2))
    # il faut fix le -2
    for i in range(taille_mat - 2):
        for j in range(taille_mat - 2):
            if i == j: # étude de la diagonale centrale
                A[i][j] = 2 + 2 * r
                B[i][j] = 2 - 2 * r
            elif (j == i + 1) or (i == j + 1): # étude des diagonales secondaires
                A[i][j] = -r
                B[i][j] = r
    return A, B


def init(T_int, T_ext, taille_mat):  # initialisation de la matrice U
    '''
        Initialisation de la matrice de température U
        
        Paramètres
        ----------
        T_int : flottant.
        T_ext : flottant
        taille_mat : entier.

        Retour
        ------
        M : tableau numpy
    '''

    M = np.full((taille_mat, taille_mat), T_int, dtype=float)  # On impose T_int partout
    M[0], M[-1], M[:, 0], M[:, -1] = T_ext, T_ext, T_ext, T_ext  # puis on impose T_ext à l'extérieur de la boîte, donc aux extrémités de la matrice

    return M


def calcul_U_t_suivant(U, T_int, taille_mat, E, A, B, λ_int, C_int, r):
    """
    Calcul de U au temps suivant.

    Paramètres
    ----------
    U : NP.ARRAY
    T_int : FLOAT
    taille_mat : INT
    E : INT
    A : NP.ARRAY
    B : NP.ARRAY
    λ_int : FLOAT
    C : FLOAT
    r : FLOAT

    Retour
    ------
    T_int : FLOAT
        Température à l'intérieur de la boite.

    """
    
    flux_th = 0
    
    for y in range(1, taille_mat - 1):  # balayage de t à t+1/2: on étudie les lignes

        if E-1 <= y <= taille_mat - E:  # on étudie le cas où on est au middle

            invA = inv(A[:E - 2, :E - 2]) #-2 car les extrémités sont fixées
            invAxB = np.dot(invA, B[:E - 2, :E - 2])

            U[y, :E] = calc_U(U[y, :E], invA, invAxB, r)
            U[y, taille_mat - E:] = calc_U(U[y, taille_mat - E:], invA, invAxB, r)
            
            flux_th += pas_spatial*N_profondeur*λ_int*(U[y,E-1]-T_int) #flux à gauche
            flux_th += pas_spatial*N_profondeur*λ_int*(U[y,taille_mat-E+1]-T_int) #flux à droite
            
        else:
            invA = inv(A)
            invAxB = np.dot(invA, B)

            U[y] = calc_U(U[y], invA, invAxB, r)  # calc_U(matrice 1D, CL1, CL2)
        
    for x in range(1, taille_mat - 1):  # balayage de t+1/2 à t+1: on étudie les colonnes

        if E-1 <= x <= taille_mat - E:
            invA = inv(A[:E - 2, :E - 2])
            invAxB = np.dot(invA, B[:E - 2, :E - 2])

            U[:E, x] = calc_U(U[:E, x], invA, invAxB, r)
            U[taille_mat - E:, x] = calc_U(U[taille_mat - E:, x], invA, invAxB, r)
            
            flux_th += pas_spatial*N_profondeur *λ_int*(U[E+1,x]-T_int) #flux en haut
            flux_th += pas_spatial*N_profondeur*λ_int*(U[taille_mat-E-1,x]-T_int) #flux en bas
            
        else:
            invA = inv(A)
            invAxB = np.dot(invA, B)

            U[:, x] = calc_U(U[:, x], invA, invAxB, r)
            
    T_int += pas_temporel*flux_th/C_int
    
    U[E-1:taille_mat-E+1,E-1:taille_mat-E+1] = T_int
    
    return T_int


def calc_U(barre, invA, invAxB, r):
    """

    Paramètres
    ----------
    barre : NP.ARRAY
    invA : NP.ARRAY
    invAxB : NP.ARRAY
    r : FLOAT

    Returns
    -------
    barre : NP.ARRAY
        Renvoie la barre avec la nouvelle température.

    """
    longueur = len(barre[1:-1])  # longueur de la barre où l'on change la température

    b = np.zeros(longueur)  # Calcul de b: ne contient pas les extrémités: 2 cases en moins
    b[0] = 2 * r * barre[0]
    b[-1] = 2 * r * barre[-1]  # on a mis 2r au lieu d'ajouter bjplus1 [longueur - 1] = r * U[longueur + 1, t]

    barre[1:-1] = np.dot(invAxB, barre[1:-1]) + np.dot(invA, b)  # application de la formule de récurrence

    return barre


########################### A F F E C T A T I O N S #######################

pas_spatial = 1*10 **-3  # (en m)
pas_temporel = 10  # (en s)

L = 0.5/5  # longueur de la boîte (en m)
temps_de_sim = 200  # Temps de la simulation (en s)
epaisseur = 0.15/20    # son épaisseur (en m)

E = int(epaisseur / pas_spatial)  # conversion de l'épaisseur en nombre de points sur la matrice
taille_mat = int(L / pas_spatial)  # taille U: correspond au nombre de lignes (= nb colonnes)

N_profondeur = 100*E  # nombres de mesures de la profondeur de la boîte pour négliger les effets de bords

ρ = 715   # masse volumique du Chêne pédonculé en kg/L
c = 2385  # J.kg/K capacité thermique massique du bois de chêne (source: https://www.thermoconcept-sarl.com/base-de-donnees-chaleur-specifique-ou-capacite-thermique/)
λ = 0.16 # conductivité thermique du bois de chêne à 298 K (W/m/K)

rho_int = 1004 # masse volumique de l'air (kg/L)
λ_int = 0.025 # conductivité thermique de l'air(W/m/K)
c_int = 1005 # capacité thermique massique de l'air (J/kg/K)
C_int = c_int*rho_int*(L-2*epaisseur)**2*100*epaisseur # Capacité thermique à l'intérieur

alpha = λ/(ρ*c)  # coefficient de diffusivité du matériau de la boite
r = alpha * pas_temporel / pas_spatial**2  # constante utilisée dans le calcul des matrices A et B pour la récurrence

A, B = matrice_AB(r, taille_mat)

T_ext = 35
T_int = 7
T_int_init = 7

########################### D E B U T  D U  P R O G R A M M E #######################

t = time.time()
U = init(T_int, T_ext, taille_mat)

nb_diterations = int(temps_de_sim / pas_temporel)  # (en s)

print("Nombre d'itérations: {} \n".format(nb_diterations))

for i in range(nb_diterations):  # on calcule U avec n itérations
    T_int = calcul_U_t_suivant(U, T_int, taille_mat, E, A, B, λ, N_profondeur, r)
    if i%20 == 0 or i == nb_diterations-1:
        print("\n"+"▓" * int(29 * ((i + 1) / nb_diterations)) + "░" * (29 - int(29 * ((i + 1) / nb_diterations))))
        print(" " * 13 + str(int(100 * (i + 1) / nb_diterations)) + "%" + "" * 13, 5*'\n')
        

plt.xlabel("Distance (en m)")
plt.ylabel("Distance (en m)")
plt.title('TEMPERATURE 2D')

plt.imshow(U, extent=[0, L, 0, L], aspect='auto', cmap='afmhot',vmin = T_int_init,vmax = T_ext)

cb = plt.colorbar()
cb.set_label("Température (en °C)")


print('\nDurée de simulation: {}s'.format(int(time.time() - t)))

plt.plot([epaisseur, L - epaisseur, L - epaisseur, epaisseur, epaisseur], [epaisseur, epaisseur, L - epaisseur, L - epaisseur, epaisseur], color='#006a4e')


plt.show()
